miscExamples <- function() {
    d <- paste("V", c(1,2,3,5), c(7,8,9,4), sep="x")
    print(d)

}

dataTableExamples <- function() {
    # Ref. https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-intro.html
    DT <- data.table(ID = c("b","b","b","b","a","a","c"), A = 1:7, B = 7:13, C = 14:20)

    # append a new column
    print("==Append==")
    DT[, D:=C+10]
    print(DT)
    
    # aggregation and in some cases add new columns; [i, j, by]
    print("==Aggregate==")
    print(DT[, sum(C+D)])
    print(DT[, sum(C+D), by=ID])
    print(DT[, .N, by=ID]) # histogram (count) by ID
    print(DT[, .N, by=.(ID,A)]) # .() for when multiple columns are involved
    print(DT[, .(.N, Z=sum(B+C)), by=.(ID,A)])
    print(DT[, .(.N, sum(B+C)), by=.(ID,A)]) # as above but column name autogenerated
    print(DT[, sum((C+B)>23), by=ID]) # count of records with (C+B)>10 and aggregate by ID
    print(DT[, sum((C+B)>23), .N]) # total count matching the expression
    print(DT[, .(ma=mean(A), md=mean(D))])
    print(DT[, .(ma=mean(A), md=mean(D)), by=ID])
    print(DT[A%%2!=0, .(ID,A,C,D,B)]) # only rows matching a condition, reorder columns
    print(DT[A%%2!=0, .(A,C,D,B), by=ID]) # by=ID has no effect since there's no aggregation
    print(DT[A%%2!=0, sum(A+B+C+D), by=ID])
    print(DT[A%%2!=0, .(A,C,D,B), keyby=.(ID)]) # sort after aggregration
    print(DT[, .N, .(B<10,D>25)]) # by can accept expressions, not just columns

    # aggregration by using .SD: subset of data
    print("==Aggregate .SD==")
    print(DT[, print(.SD), by=ID])
    print(DT[, lapply(.SD, mean), by=ID])
    print(DT[, lapply(.SD, sd), by=ID]) # standard deviation will return NA when there is only one sample
    print(DT[, lapply(.SD, max), by=ID, .SDcols=c("A","B")]) # only some columns
    print(DT[, head(.SD, 1), by=ID]) # only 1st row of each group
    print(DT[, .(val = c(A,B)), by=ID]) # concatenate A and B by ID
    print(DT[, .(val = list(c(A,B))), by=ID]) # concatenate and return as list
    
    # returns a vector
    print("==Return vector==")
    ccol <- DT[,C]
    print(c(class(ccol), ccol))

    # returns a data.table
    print("==Return data.table==")
    ccol <- DT[,list(C)]
    print(c(class(ccol), ccol))
    ccol <- DT[,.(C)] # dot is an alternative to list
    print(c(class(ccol), ccol))
    ccol <- DT[,.(aa=A,cc=C)] # multiple columns and rename
    print(c(class(ccol), ccol))

    # returns a data.table by traditional data.frame syntax
    print("==Return data.table using with=FALSE==")
    ccol <- DT[, c("A","C"), with=F]
    print(c(class(ccol), ccol))
    ccol <- DT[, !c("A","C"), with=F] # all columns except A and C
    print(c(class(ccol), ccol))
    
    # subsetting rows
    print("==Subset Rows==")
    print(DT[DT$ID=="b",]) # using comma with data.table is accepted though not necessary
    print(DT[ID=="b"]) # comma not required as in data.frame, ID can be used instead of DT$ID
    print(DT[1:2]) # first two rows

    # ordering
    print("==Order==")
    print(DT[order(ID,-B)]) # ascending ID, descending B
    print(DT[A%%2!=0, .(A,B,Z=sum(C+D)), by=ID][order(-Z,ID)])  # shows chaining of operations using [][]...

    return(DT)
}

makeVector <- function(x = numeric()) {
    m <- NULL
    set <- function(y) {
        x <<- y
        m <<- NULL
    }
    get <- function() x
    setmean <- function(mean) m <<- mean
    getmean <- function() m
    list(set = set, get = get,
         setmean = setmean,
         getmean = getmean)
}

cachemean <- function(x, ...) {
    m <- x$getmean()
    if(!is.null(m)) {
        message("getting cached data")
        return(m)
    }
    data <- x$get()
    m <- mean(data, ...)
    x$setmean(m)
    m
}

makeCacheMatrix <- function(x = matrix()) {
    m <- NULL
    set <- function(y) {
        x <<- y
        m <<- NULL
    }
    get <- function() x
    setinv <- function(solve) m <<- solve
    getinv <- function() m
    list(set = set, get = get,
         setinv = setinv,
         getinv = getinv)
}

cacheSolve <- function(x, ...) {
    m <- x$getinv()
    if(!is.null(m)) {
        message("getting cached data")
        return(m)
    }
    data <- x$get()
    m <- solve(data, ...)
    x$setinv(m)
    m
}

irisAnalysis <- function() {
    library(datasets)
    data(iris)
    
    # Mean of Sepal.Length for virginica
    v <- iris[iris["Species"]=="virginica",]
    print(round(mean(v$Sepal.Length)))

    # Mean of metrics across species
    print(colMeans(iris[, 1:4]))
    print(sapply(iris[, 1:4], mean))
}

mtcarsAnalysis <- function() {
    library(datasets)
    data(mtcars)

    # Mean miles per gallon by no. of cylinders
    print(tapply(mtcars$mpg, mtcars$cyl, mean))
    print(with(mtcars, tapply(mpg,cyl,mean)))
    print(sapply(split(mtcars$mpg, mtcars$cyl), mean))
    
    # Absolute difference in horsepower
    hp <- tapply(mtcars$hp, mtcars$cyl, mean)
    print(round(abs(hp["4"] - hp["8"])))
}

printme <- function(x) {
    if (x > 0) print("x is positive.")
    else print("x is zero or negative.")
    invisible(x)
}

colmean <- function(x, removeNA = TRUE) {
    nc <- ncol(x)
    means <- numeric(nc)
    for (i in 1:nc) {
        means[i] <- mean(x[, i], na.rm = removeNA)
    }
    means
}

make.power <- function(n) {
    pow <- function(x) {
        x^n
    }
    pow
}
cube <- make.power(3)
sqr <- make.power(2)

orderme <- function() {
    dd <- data.frame(b = factor(c("Hi", "Med", "Hi", "Low"), 
            levels = c("Low", "Med", "Hi"), ordered = TRUE),
            x = c("A", "D", "A", "C"), y = c(8, 3, 9, 9),
            z = c(1, 1, 1, 2))
    print(dd[with(dd, order(-z, b)), ])
    print(dd[order(-dd$z, dd$b),])
    print(dd[ order(-dd[,4], dd[,1]), ])
}

secsnow <- function() {
    now <- Sys.time() # now is in POSIXct
    print(unclass(now))
    print(strftime(now, "%B %d, %Y %H:%M:%S"))
    y <- unclass(as.POSIXlt(now))
    print(names(y))
    print(y$sec)
}

namer <- function() {
    df <- setNames(data.frame(as.list(1:5)), LETTERS[1:5])
    print(df[,c("A","B","E")])
}

